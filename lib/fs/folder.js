// Generated by CoffeeScript 1.12.3
(function() {
  'use strict';
  var errorReport, fs, path;

  fs = require('fs');

  path = require('path');

  errorReport = require('../error_report');

  module.exports = {
    errors: {
      order: ['pathError', 'folderEmpty'],
      detectors: {
        pathError: function(title, path, files) {
          if (typeof files === 'string') {
            return [title, files];
          }
          return false;
        },
        folderEmpty: function(title, path, files) {
          if (!files.length) {
            return [title, path];
          }
          return false;
        }
      },
      messages: {
        pathError: function(title, path) {
          return {
            title: "Module '" + title + "' folder missing",
            messages: ["Directory '" + path + "' does not exist."]
          };
        },
        folderEmpty: function(title, path) {
          return {
            title: "Module '" + title + "' folder empty",
            messages: ["No files found in '" + path + "'."]
          };
        }
      }
    },
    isFolder: function(dir) {
      var e, folder;
      try {
        folder = fs.lstatSync(path.join(dir)).isDirectory();
      } catch (error) {
        e = error;
        folder = false;
      }
      return folder;
    },
    read: function(title, dir, recursive) {
      var e, files, i, j, methodList, names, ref;
      dir = this.getDir(dir);
      try {
        files = this.getFiles(dir, recursive);
      } catch (error) {
        e = error;
        files = dir;
      }
      if (errorReport.toTestEngine(this.errors, [title, dir, files])) {
        return false;
      }
      files = files.map(function(filename) {
        var method, ref;
        ref = filename.split('.'), method = ref[0];
        return method;
      });
      names = files.map(function(filePath) {
        return filePath.split('/').join('.');
      });
      files = files.map(function(filename) {
        return dir + "/" + filename;
      });
      methodList = {};
      for (i = j = 0, ref = names.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        methodList[names[i]] = files[i];
      }
      return methodList;
    },
    getFiles: function(dir, recursive) {
      var _;
      return _ = recursive ? this.getFilesRecursively(dir) : fs.readdirSync(dir).filter(function(file) {
        return fs.statSync(path.join(dir, file)).isFile();
      });
    },
    getFilesRecursively: function(dir) {
      var _, files;
      files = this.walkSync(dir, []);
      return _ = files.map(function(filename) {
        return filename.replace(dir + "/", '');
      });
    },
    walkSync: function(dir, filelist) {
      var file, files, j, len;
      files = fs.readdirSync(dir);
      filelist = filelist || [];
      for (j = 0, len = files.length; j < len; j++) {
        file = files[j];
        if (fs.statSync(path.join(dir, file)).isDirectory()) {
          filelist = this.walkSync(path.join(dir, file), filelist);
        } else {
          filelist.push(path.join(dir, file));
        }
      }
      return filelist;
    },
    getDir: function(dir) {
      if (fs.existsSync(dir)) {
        return dir;
      }
      return "node_modules/" + dir;
    }
  };

}).call(this);
