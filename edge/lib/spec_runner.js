// Generated by CoffeeScript 1.12.3
(function() {
  'use strict';
  var sequenceSyntax, testEngine;

  sequenceSyntax = require('./sequence_syntax');

  testEngine = require('./test_engine');

  module.exports = {
    mochaMethods: ['it', 'specify', 'xit', 'xspecify'],
    process: function(specSet, code, name, matchers, use, tapeContext) {
      var specSetParams;
      specSetParams = this.parseSpecSetParams(code, name, matchers, use, tapeContext);
      if (!Array.isArray(specSet)) {
        specSet = [specSet];
      }
      specSet = this.processSpecSet(specSet, specSetParams);
      return testEngine.outputTape(specSet);
    },
    parseSpecSetParams: function(code, name, matchers, use, tapeContext) {
      var _;
      return _ = {
        code: code,
        matchers: matchers,
        methodName: name,
        sharedSpecKeys: {},
        specs: [],
        tapeContext: tapeContext,
        use: use
      };
    },
    processSpecSet: function(specSet, specSetParams) {
      var i, len, spec, specParams, specs;
      for (i = 0, len = specSet.length; i < len; i++) {
        spec = specSet[i];
        specParams = this.collectSpecParams(spec, specSetParams);
        if (specParams) {
          testEngine.outputMocha(specParams, specSetParams);
        }
        specs = specSetParams.specs.concat(specParams);
        specSetParams.specs = specs;
      }
      return specSetParams;
    },
    collectSpecParams: function(spec, specSetParams) {
      var ref, specParams;
      if (!this.itIsSingle(spec) && !this.itIsSequence(spec)) {
        specSetParams.sharedSpecKeys = spec;
        return false;
      }
      specParams = {
        mochaMethod: this.getMochaMethod(spec),
        matcher: (ref = spec.matcher) != null ? ref : 'default'
      };
      this.addSharedKeys(specParams, specSetParams);
      if (spec.before) {
        specParams.before = spec.before;
      }
      if (spec.after) {
        specParams.after = spec.after;
      }
      return this.processSpecData(spec, specParams);
    },
    getMochaMethod: function(spec) {
      var i, keys, len, mochaMethod, ref;
      keys = Object.keys(spec);
      ref = this.mochaMethods;
      for (i = 0, len = ref.length; i < len; i++) {
        mochaMethod = ref[i];
        if (keys.indexOf(mochaMethod) !== -1) {
          return mochaMethod;
        }
      }
      return false;
    },
    processSpecData: function(spec, specParams) {
      var _;
      return _ = this.itIsSequence(spec, specParams) ? this.generateSequence(spec, specParams) : this.generateSingle(spec, specParams);
    },
    itIsSingle: function(spec) {
      if (spec.i == null) {
        return false;
      }
      if (spec.e == null) {
        return false;
      }
      return true;
    },
    itIsSequence: function(spec, specParams) {
      if (!(spec.data && typeof spec.data === 'object')) {
        return false;
      }
      return true;
    },
    addSharedKeys: function(specParams, specSetParams) {
      var key, ref, value;
      if (!Object.keys(specSetParams.sharedSpecKeys).length) {
        return;
      }
      ref = specSetParams.sharedSpecKeys;
      for (key in ref) {
        value = ref[key];
        specParams[key] = value;
      }
      return specParams;
    },
    generateSingle: function(spec, specParams) {
      return [sequenceSyntax.setSpecData(specParams, spec.i, spec.e, spec[specParams.mochaMethod])];
    },
    generateSequence: function(specSequence, specParams) {
      var from, i, ref, ref1, ref2, sequence, specIndex, till;
      sequence = [];
      from = (ref = specSequence.from) != null ? ref : 1;
      specSequence.from = from;
      till = from + specSequence.data.length - 1;
      for (specIndex = i = ref1 = from, ref2 = till; ref1 <= ref2 ? i <= ref2 : i >= ref2; specIndex = ref1 <= ref2 ? ++i : --i) {
        sequence.push(sequenceSyntax.parse(specSequence, specIndex, specParams));
      }
      return sequence;
    }
  };

}).call(this);
