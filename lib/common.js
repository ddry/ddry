// Generated by CoffeeScript 1.12.3
(function() {
  'use strict';
  module.exports = {
    construct: function(constructor, args) {
      var F;
      F = function() {
        return constructor.apply(this, args);
      };
      F.prototype = constructor.prototype;
      return new F();
    },
    containsObjects: function(value) {
      var element, j, len;
      for (j = 0, len = value.length; j < len; j++) {
        element = value[j];
        if (element && typeof element === 'object') {
          return true;
        }
      }
      return false;
    },
    create: function(object, baseKey, report, raw) {
      var finalValue, key, value;
      if (baseKey == null) {
        baseKey = [];
      }
      if (report == null) {
        report = [];
      }
      if (raw == null) {
        raw = false;
      }
      for (key in object) {
        value = object[key];
        if (this.validObject(value)) {
          report = this.create(value, baseKey.concat([key]), report, raw);
        } else {
          finalValue = {};
          finalValue[baseKey.concat([key]).join('.')] = raw ? value : this.format(value);
          report.push(finalValue);
        }
      }
      return report;
    },
    format: function(value) {
      var definition;
      if (typeof value === 'function') {
        definition = ("" + value).replace(/ /g, '');
        return definition.replace(/__cov_[^\+]*\+\+;/g, '');
      }
      return "" + value;
    },
    forMocha: function() {
      return typeof describe === 'function';
    },
    insertKey: function(lo, key, value) {
      var arrayFollows, cursor, i, j, nextNode, node, ref, target, xPath;
      xPath = key.split('.');
      target = xPath.pop();
      cursor = lo;
      if (xPath.length) {
        for (i = j = 0, ref = xPath.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          node = xPath[i];
          arrayFollows = /^\d+$/.test(xPath[i + 1]);
          nextNode = arrayFollows ? [] : {};
          cursor[node] = cursor[node] || nextNode;
          cursor = cursor[node];
        }
      }
      cursor[target] = value;
      return lo;
    },
    mergeHashes: function(lo, hi) {
      var key, value;
      for (key in hi) {
        value = hi[key];
        lo[key] = value;
      }
      return lo;
    },
    mergeObjects: function(lo, hi) {
      var key, report, value;
      report = this.report(hi, true);
      for (key in report) {
        value = report[key];
        lo = this.insertKey(lo, key, value);
      }
      return lo;
    },
    report: function(value, hash) {
      var j, key, len, report, reportHash;
      if (hash == null) {
        hash = false;
      }
      if (!this.validObject(value)) {
        return this.format(value);
      }
      report = this.create(value, null, null, hash);
      if (!hash) {
        return report;
      }
      reportHash = {};
      for (j = 0, len = report.length; j < len; j++) {
        key = report[j];
        reportHash = this.mergeHashes(reportHash, key);
      }
      return reportHash;
    },
    validObject: function(value) {
      if (!(value && typeof value === 'object')) {
        return false;
      }
      if (Array.isArray(value)) {
        if (!this.containsObjects(value)) {
          return false;
        }
      }
      if (!Object.keys(value).length) {
        return false;
      }
      return true;
    }
  };

}).call(this);
