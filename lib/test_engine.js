// Generated by CoffeeScript 1.12.3
(function() {
  'use strict';
  var performTest, tapeRunner;

  performTest = require('./perform_test');

  if (typeof describe !== 'function') {
    tapeRunner = require('./tape_runner');
  }

  module.exports = {
    output: true,
    muteOutput: function() {
      return this.output = false;
    },
    forMocha: function() {
      return typeof describe === 'function';
    },
    modular: function(dd) {
      if (!this.output) {
        return;
      }
      if (!this.forMocha()) {
        return tapeRunner.process(dd);
      }
    },
    runModuleSpecFolder: function(dd, title, methodList) {
      var that;
      if (!this.forMocha()) {
        return this.processMethodList(dd, methodList);
      }
      that = this;
      return describe(title, function() {
        return that.processMethodList(dd, methodList);
      });
    },
    processMethodList: function(dd, methodList) {
      var methodFile, methodName, results;
      results = [];
      for (methodName in methodList) {
        methodFile = methodList[methodName];
        results.push(dd.method(methodName, methodFile));
      }
      return results;
    },
    describeModule: function(dd, params, specs) {
      if (!this.output) {
        return;
      }
      if (!this.forMocha()) {
        return;
      }
      return describe(params.title, function() {
        return specs(dd.that);
      });
    },
    describeMethod: function(dd, name, specs) {
      if (!this.output) {
        return;
      }
      if (!this.forMocha()) {
        return;
      }
      if (dd.use) {
        specs(dd, dd.that.use);
        return;
      }
      if (typeof dd.methodName === 'boolean') {
        return specs(dd, dd.that);
      } else {
        return describe(name + "()", function() {
          return specs(dd, dd.that);
        });
      }
    },
    outputMocha: function(specParams, specSet) {
      if (!this.output) {
        return;
      }
      if (!this.forMocha()) {
        return;
      }
      if (specSet.use) {
        return specParams.forEach(function(spec) {
          return global[spec.mochaMethod](spec.message, function() {
            return specSet.matchers[spec.matcher](specSet.code, spec.input, spec.expected);
          });
        });
      } else {
        return specParams.forEach(function(spec) {
          return global[spec.mochaMethod](spec.message, function() {
            return performTest(spec, specSet);
          });
        });
      }
    },
    outputTape: function(specSet) {
      var i, len, ref, results, spec;
      if (!this.output) {
        return;
      }
      if (this.forMocha()) {
        return;
      }
      ref = specSet.specs;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        spec = ref[i];
        results.push(performTest(spec, specSet));
      }
      return results;
    },
    report: function(report) {
      if (!this.output) {
        return;
      }
      if (this.forMocha()) {
        return this.reportToMocha(report);
      }
      return this.reportToTape(report);
    },
    reportToMocha: function(report) {
      var i, len, results, statement;
      results = [];
      for (i = 0, len = report.length; i < len; i++) {
        statement = report[i];
        results.push(describe(statement.title, function() {
          var j, len1, messages, ref, results1;
          ref = statement.messages;
          results1 = [];
          for (j = 0, len1 = ref.length; j < len1; j++) {
            messages = ref[j];
            results1.push(it(messages));
          }
          return results1;
        }));
      }
      return results;
    },
    reportToTape: function(report) {
      var i, len, messages, results, statement;
      console.log(" \n \n");
      results = [];
      for (i = 0, len = report.length; i < len; i++) {
        statement = report[i];
        console.log("\x1b[0m" + statement.title);
        results.push((function() {
          var j, len1, ref, results1;
          ref = statement.messages;
          results1 = [];
          for (j = 0, len1 = ref.length; j < len1; j++) {
            messages = ref[j];
            results1.push(console.log("  \x1b[36m- " + messages + "\x1b[0m"));
          }
          return results1;
        })());
      }
      return results;
    }
  };

}).call(this);
