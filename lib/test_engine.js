// Generated by CoffeeScript 1.12.3
(function() {
  'use strict';
  var performTest, tapeRunner, testOutputs;

  performTest = require('./perform_test');

  testOutputs = require('./test_outputs');

  if (typeof describe !== 'function') {
    tapeRunner = require('./tape_runner');
  }

  module.exports = {
    output: true,
    muteOutput: function() {
      return this.output = false;
    },
    forMocha: function() {
      return typeof describe === 'function';
    },
    modular: function(dd, output, forMocha, testTapeRunner) {
      if (output == null) {
        output = this.output;
      }
      if (!output) {
        return false;
      }
      if (forMocha == null) {
        forMocha = this.forMocha();
      }
      if (forMocha) {
        return false;
      }
      tapeRunner = tapeRunner || testTapeRunner;
      tapeRunner.process(dd);
      return true;
    },
    runModuleSpecFolder: function(dd, title, methodList) {
      var that;
      if (!this.forMocha()) {
        return this.processMethodList(dd, methodList);
      }
      that = this;
      return describe(title, function() {
        return that.processMethodList(dd, methodList);
      });
    },
    processMethodList: function(dd, methodList) {
      var methodFile, methodName, results;
      results = [];
      for (methodName in methodList) {
        methodFile = methodList[methodName];
        results.push(dd.method(methodName, methodFile));
      }
      return results;
    },
    describeModule: function(dd, params, specs) {
      if (!this.output) {
        return false;
      }
      if (!this.forMocha()) {
        return false;
      }
      describe(params.title, function() {
        return specs(dd.that);
      });
      return true;
    },
    describeMethod: function(dd, name, specs) {
      if (!this.output) {
        return false;
      }
      if (!this.forMocha()) {
        return false;
      }
      if (dd.use) {
        specs(dd, dd.that.use);
        true;
      }
      if (typeof dd.methodName === 'boolean') {
        specs(dd, dd.that);
      } else {
        describe(name + "()", function() {
          return specs(dd, dd.that);
        });
      }
      return true;
    },
    outputMocha: function(specParams, specSet) {
      if (!this.output) {
        return;
      }
      if (!this.forMocha()) {
        return;
      }
      if (specSet.use) {
        return specParams.forEach(function(spec) {
          return global[spec.mochaMethod](spec.message, function() {
            return specSet.matchers[spec.matcher](specSet.code, spec.input, spec.expected);
          });
        });
      } else {
        return specParams.forEach(function(spec) {
          return global[spec.mochaMethod](spec.message, function() {
            return performTest(spec, specSet);
          });
        });
      }
    },
    outputTape: function(specSet) {
      var i, len, ref, results, spec;
      if (!this.output) {
        return;
      }
      if (this.forMocha()) {
        return;
      }
      ref = specSet.specs;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        spec = ref[i];
        results.push(performTest(spec, specSet));
      }
      return results;
    },
    sendOutput: function(type, argArray) {
      if (!this.output) {
        return false;
      }
      if (this.forMocha()) {
        return testOutputs[type].toMocha.apply(this, argArray);
      }
      return testOutputs[type].toTape.apply(this, argArray);
    }
  };

}).call(this);
