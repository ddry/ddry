// Generated by CoffeeScript 1.12.3
(function() {
  'use strict';
  var sequenceSyntax, testEngine;

  sequenceSyntax = require('./syntax');

  testEngine = require('../test/engine');

  module.exports = {
    mochaMethods: ['xit', 'xspecify', 'it', 'specify'],
    process: function(specSet, code, name, dd, tapeContext) {
      var specSetParams;
      specSetParams = this.parseSpecSetParams(code, name, dd, tapeContext);
      if (!Array.isArray(specSet)) {
        specSet = [specSet];
      }
      specSet = this.processSpecSet(specSet, specSetParams);
      testEngine.outputTape(specSet);
      return specSet;
    },
    parseSpecSetParams: function(code, name, dd, tapeContext) {
      var _;
      return _ = {
        code: code,
        harness: dd.harness,
        matchers: dd.matchers,
        methodName: name,
        sharedSpecKeys: {},
        specs: [],
        tapeContext: tapeContext,
        use: dd.use
      };
    },
    processSpecSet: function(specSet, specSetParams) {
      var j, len, spec, specParams, specs;
      for (j = 0, len = specSet.length; j < len; j++) {
        spec = specSet[j];
        specParams = this.collectSpecParams(spec, specSetParams);
        if (specParams) {
          testEngine.outputMocha(specParams, specSetParams);
        }
        specs = specSetParams.specs.concat(specParams);
        specSetParams.specs = specs;
      }
      return specSetParams;
    },
    collectSpecParams: function(spec, specSetParams) {
      var ref, specParams;
      if (!this.itIsSingle(spec) && !this.itIsSequence(spec)) {
        specSetParams.sharedSpecKeys = spec;
        return [];
      }
      specParams = {
        matcher: (ref = spec.matcher) != null ? ref : 'default'
      };
      this.addSharedKeys(specParams, specSetParams);
      this.applyMochaMethod(spec, specParams);
      if (spec.before) {
        specParams.before = spec.before;
      }
      if (spec.after) {
        specParams.after = spec.after;
      }
      return this.processSpecData(spec, specParams);
    },
    getMochaMethod: function(spec) {
      var j, keys, len, mochaMethod, ref;
      keys = Object.keys(spec);
      ref = this.mochaMethods;
      for (j = 0, len = ref.length; j < len; j++) {
        mochaMethod = ref[j];
        if (keys.indexOf(mochaMethod) !== -1) {
          return mochaMethod;
        }
      }
      return false;
    },
    getPendingMessage: function(message) {
      if (typeof message !== 'string') {
        return 'pending';
      }
      if (!message.length) {
        return 'pending';
      }
      return message;
    },
    setSpecMessage: function(pending, spec) {
      if (typeof spec === 'string') {
        return pending + ": " + spec;
      }
      return function(i, e) {
        return pending + ": " + (spec(i, e));
      };
    },
    applyMochaMethod: function(spec, specParams) {
      var paramsMethod, pendingMessage, specMessage;
      paramsMethod = this.getMochaMethod(specParams);
      if (paramsMethod) {
        pendingMessage = this.getPendingMessage(specParams[paramsMethod]);
        specMessage = spec[this.getMochaMethod(spec)];
        spec[paramsMethod] = this.setSpecMessage(pendingMessage, specMessage);
      }
      return specParams.mochaMethod = this.getMochaMethod(spec);
    },
    processSpecData: function(spec, specParams) {
      var _;
      return _ = this.itIsSequence(spec, specParams) ? this.generateSequence(spec, specParams) : this.generateSingle(spec, specParams);
    },
    itIsSingle: function(spec) {
      var keys;
      keys = Object.keys(spec);
      if (keys.indexOf('i') === -1) {
        return false;
      }
      if (keys.indexOf('e') === -1) {
        return false;
      }
      return true;
    },
    itIsSequence: function(spec, specParams) {
      if (!(spec.data && typeof spec.data === 'object')) {
        return false;
      }
      return true;
    },
    addSharedKeys: function(specParams, specSetParams) {
      var key, ref, value;
      if (!Object.keys(specSetParams.sharedSpecKeys).length) {
        return;
      }
      ref = specSetParams.sharedSpecKeys;
      for (key in ref) {
        value = ref[key];
        specParams[key] = value;
      }
      return specParams;
    },
    generateSingle: function(spec, specParams) {
      return [sequenceSyntax.setSpecData(specParams, spec.i, spec.e, spec[specParams.mochaMethod])];
    },
    generateSequence: function(specSequence, specParams) {
      var from, j, ref, ref1, ref2, sequence, specIndex, till;
      sequence = [];
      from = (ref = specSequence.from) != null ? ref : 1;
      specSequence.from = from;
      till = from + specSequence.data.length - 1;
      for (specIndex = j = ref1 = from, ref2 = till; ref1 <= ref2 ? j <= ref2 : j >= ref2; specIndex = ref1 <= ref2 ? ++j : --j) {
        sequence.push(sequenceSyntax.parse(specSequence, specIndex, specParams));
      }
      return sequence;
    }
  };

}).call(this);
