// Generated by CoffeeScript 1.12.6

/*
 * Command line interface usage informer
 */

(function() {
  'use strict';
  var c;

  c = require('../common/colors');

  module.exports = {
    brief: "\n" + (c.ddry()) + " " + (c.bright(' command line interface usage summary')) + "\n\n  " + (c.green('Commands:')) + "\n    " + (c.bright('init')) + " or " + (c.bright('i')) + "           Initialize config file\n    " + (c.bright('add')) + " or " + (c.bright('a')) + "            Add a named value to spec config file " + (c.bright('(ddry.json)')) + "\n    " + (c.bright('addScope')) + " or " + (c.bright('as')) + "      Add a spec execution scope (except or only) to " + (c.bright('ddry.json')) + "\n    " + (c.bright('config')) + " or " + (c.bright('c')) + "         Generate config with specified configurer module returning config object with given parameters\n    " + (c.bright('usage')) + " or " + (c.bright('u')) + "          Get usage info for a specific command or usage summary. Also " + (c.bright('h')) + " and " + (c.bright('?')) + " are supported\n    " + (c.bright('remove')) + " or " + (c.bright('r')) + "         Remove a named value from config file " + (c.bright('(ddry.json)')) + "\n    " + (c.bright('removeScope')) + " or " + (c.bright('rs')) + "   Remove a spec execution scope (except or only) from " + (c.bright('ddry.json')) + "\n    " + (c.bright('titles')) + " or " + (c.bright('t')) + "         Parse target code folder files for module titles, save found to " + (c.bright('ddry.json')) + "\n\n  " + (c.blue('Suite execution scoping:')) + "\n    " + (c.bright('When running')) + " " + (c.ddry()) + " " + (c.bright('specs from inside test harness')) + "\n      Simply provide your test harness with " + (c.bright('node_modules/ddry/ddry.js')) + " — it will pass to harness your suite\n      configured and scoped with " + (c.bright('ddry.json')) + ". Customize it with 'add', 'remove', 'addScope' and 'removeScope'\n      commands or plain editing.\n\n    " + (c.bright('When running')) + " " + (c.ddry()) + " " + (c.bright('specs from harness-specific CLI tool')) + "\n      " + (c.ddry()) + " optional dependencies packages include three harness-specific CLI tools for Mocha JS, TAP and Tape JS,\n      respectively: " + (c.bright('ddry-mocha')) + ", " + (c.bright('ddry-tap')) + " and " + (c.bright('ddry-tape')) + ". Their sole purpose is to run the scoped suite with the test\n      harness of your choice right in one shell command. Below examples use " + (c.bright('ddry-mocha')) + ", meaning that you should use\n      the tool for the test harness of your choice.\n\n      $ ddry-mocha -o <spec or code file or folder path(s), `tab` completed>\n        — running " + (c.bright('only')) + " specified modules or module methods specs\n      $ ddry-mocha -e <spec or code file or folder path(s), `tab` completed>\n        — running the whole suite " + (c.bright('except')) + " specified modules or module methods specs\n\n      Only and except strategies may be combined in any order as long as -o and -e keys are used once:\n      $ ddry-mocha -o spec/lib/examples -e spec/lib/examples/instances spec/examples/selenium\n",
    add: "\n" + (c.bright('add')) + " or " + (c.bright('a')) + " — Add a named value to spec config file " + (c.bright('(ddry.json)')) + "\n  Create an empty array with " + (c.bright('[]')) + " keyword or an empty object with " + (c.bright('{}')) + ". Add new key-value pairs to objects\n  using the dotted notation or populate arrays with new elements.\n\n  Syntax:\n    $ ddry a <config.object.key.in.dotted.notation> <value>\n  Examples:\n    $ ddry a methods.examples.properties.only []\n    $ ddry a methods.examples.properties.only setFew\n",
    addScope: "\n" + (c.bright('addScope')) + " or " + (c.bright('as')) + " — Add a spec execution scope (except or only) to " + (c.bright('ddry.json')) + " for:\n  — modules folder of any depth (" + (c.bright('code')) + " or " + (c.bright('spec')) + " folders recognized)\n  — single modules (" + (c.bright('code')) + " or " + (c.bright('spec')) + " folder files recognized)\n  — certain methods of certain modules (only " + (c.bright('spec')) + " folder files recognized)\n\n  Syntax:\n    $ ddry as <-o|-e> <spec or code file or folder path(s), `tab` completed>\n  Examples:\n    $ ddry as -o spec/lib/examples/properties/setFew.js spec/examples/properties/ spec/lib/examples/instance\n    $ ddry as -e spec/lib/fs lib/modular lib/common/object/clone.js\n",
    config: "\n" + (c.bright('config')) + " or " + (c.bright('c')) + " — Generate config with specified configurer module returning config object with given parameters\n\n  The " + (c.bright('config')) + " command gives you access to ultimate automation of data-driven spec configuring. The point is that\n  you create the module that takes some arguments and returns the config object to be saved as " + (c.bright('ddry.json')) + " and used\n  as spec config file. This flexibility makes multiple configurer files pointless, so after you've specified\n  the configurer module path at least once, you may omit it and just give the parameters to be passed to your\n  configurer module. You may check the configurer path and passed parameters in the automatically added " + (c.bright('cli.config')) + "\n  section of " + (c.bright('ddry.json')) + ".\n\n  You also may use harness-specific tools " + (c.bright('ddry-mocha')) + ", " + (c.bright('ddry-tap')) + " and " + (c.bright('ddry-tape')) + " to feed the generated config file\n  to the harness of your choice on the fly, in one shell command.\n\n  Syntax:\n    $ ddry[-<harness>] [<configurer module path, `tab` completed>] <arguments to be passed to your configurer>\n  Examples:\n    $ ddry spec/config nd\n    $ ddry-tape ne\n",
    init: "\n" + (c.bright('init')) + " or " + (c.bright('i')) + " — Initialize config file\n  Creates minimum viable data-driven testing configuration file " + (c.bright('ddry.json')) + " with\n  — " + (c.ddry()) + " convention-over-configuration spec folder " + (c.bright('(mandatory)')) + "\n  — target code folder " + (c.bright('(optional)')) + "\n  — whole spec suite title " + (c.bright('(optional)')) + "\n\n  Of course, right from this point and as long as possible further intensive use of shell file and folder\n  paths `tab` completion is strongly encouraged.\n\n  Default " + (c.bright('title')) + " equals " + (c.bright('spec')) + ".\n\n  Code folder is optional, you may have all your modules added as " + (c.bright('outside')) + ". Please check " + (c.ddry()) + " documentation\n  for this advanced config option. The point of this optionality is to make config init more welcoming.\n\n  If you wish to set a suite title without specifying the code folder, use `.` (dot) as second parameter,\n  it will be ignored.\n\n  Syntax:\n    $ ddry i <spec> [<code>] [<title>]\n  Examples:\n    $ ddry i spec/ lib/ \"Human friendly test suite title\"\n    $ ddry i spec/\n    $ ddry i spec/ . \"I don't have code folder, but I want to set title\"\n",
    usage: "\n" + (c.bright('usage')) + " or " + (c.bright('u')) + " — Get usage info for a specific command or usage summary. Also " + (c.bright('h')) + " and " + (c.bright('?')) + " are supported\n  If the command you ask about is recognized, its usage info is returned. Missing or misspelled command name result\n  in brief usage summary being returned.\n\n  Harness-specific tools will also yield usage info, but will exit without launching the test harness.\n\n  Syntax:\n    $ ddry <h|u|?> [<command name>]\n  Examples:\n    $ ddry ? ?\n    $ ddry u addScope\n",
    remove: "\n" + (c.bright('remove')) + " or " + (c.bright('r')) + " — Remove a named value from spec config file " + (c.bright('(ddry.json)')) + "\n  Remove previously set object key-value pairs or arrays elements. For objects only dot-notated property name is required, including\n  numeric indexes of array elements since arrays are objects in JS. This approach is quite fruitful, but requires you to know the index\n  of the array element you wish to remove, what is rather uncomfortable. To deal with arrays the more realistic way you may specify\n  the second argument which will be removed once found in the target array.\n\n  However, somehow you'll may find manual editing of " + (c.bright('ddry.json')) + " more comfortable.\n\n  Syntax:\n    $ ddry r <config.object.key.in.dotted.notation> [<value>]\n  Example:\n    $ ddry r only.1\n    $ ddry r methods.examples.properties.except setFew\n\n",
    removeScope: "\n" + (c.bright('removeScope')) + " or " + (c.bright('rs')) + " — Remove a previously set spec execution scope (except or only) from " + (c.bright('ddry.json')) + " for:\n  — modules folder of any depth (" + (c.bright('code')) + " or " + (c.bright('spec')) + " folders recognized)\n  — single modules (" + (c.bright('code')) + " or " + (c.bright('spec')) + " folder files recognized)\n  — certain methods of certain modules (only " + (c.bright('spec')) + " folder files recognized)\n\n  However, somehow you'll may find manual editing of " + (c.bright('ddry.json')) + " more comfortable.\n\n  Syntax:\n    $ ddry rs <-o|-e> <spec or code file or folder path(s), `tab` completed>\n  Examples:\n    $ ddry rs -o spec/lib/examples/properties/setFew.js spec/examples/properties/ spec/lib/examples/instance\n    $ ddry rs -e spec/lib/fs lib/modular lib/common/object/clone.js\n",
    titles: "\n" + (c.bright('titles')) + " or " + (c.bright('t')) + " — Parse target code folder files for module titles, save found to " + (c.bright('ddry.json')) + "\n  Human-friendly module title is taken from the first block comment in module code. Once you named your modules this way, refresh\n  the spec config with this no arguments command. It also will parse the modules included to spec as " + (c.bright('outside')) + ".\n\n  Syntax:\n    $ ddry t\n"
  };

}).call(this);
