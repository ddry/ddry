// Generated by CoffeeScript 2.4.1
(function() {
  /*
   * Commonly used object methods
   */
  'use strict';
  var report;

  report = require('./report');

  module.exports = {
    extend: report.extend,
    format: report.format,
    isObject: report.isObject,
    report: report.create,
    construct: function(constructor, args) {
      var F;
      F = function() {
        return constructor.apply(this, args);
      };
      F.prototype = constructor.prototype;
      return new F();
    },
    insertKey: function(lo, key, value) {
      var arrayFollows, cursor, i, j, nextNode, node, ref, target, xPath;
      xPath = key.split('.');
      target = xPath.pop();
      cursor = lo;
      if (xPath.length) {
        for (i = j = 0, ref = xPath.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          node = xPath[i];
          arrayFollows = /^\d+$/.test(xPath[i + 1]);
          nextNode = arrayFollows ? [] : {};
          cursor[node] = cursor[node] || nextNode;
          cursor = cursor[node];
        }
      }
      return this.insertValue(lo, cursor, target, value);
    },
    insertValue: function(lo, cursor, target, value) {
      var node;
      node = cursor[target];
      if (Array.isArray(node)) {
        value = this.toArray(value);
        cursor[target] = node.concat(value);
        return lo;
      }
      if (this.isObject(node) && this.isObject(value)) {
        node = this.extend(node, value);
        return lo;
      }
      cursor[target] = value;
      return lo;
    },
    match: function(hashKey, keys, full = false, trigger = false) {
      var hashKeys, hashSplit, j, k, len, len1, match, node, xPath;
      hashKeys = this.toArray(hashKey);
      for (j = 0, len = hashKeys.length; j < len; j++) {
        hashKey = hashKeys[j];
        match = full ? hashKey : true;
        if (keys.indexOf(hashKey) !== -1) {
          return match;
        }
        hashSplit = hashKey.split('.');
        xPath = [];
        for (k = 0, len1 = hashSplit.length; k < len1; k++) {
          node = hashSplit[k];
          xPath.push(node);
          if (trigger) {
            match = xPath.join('.');
          }
          if (keys.indexOf(xPath.join('.')) !== -1) {
            return match;
          }
        }
      }
      return false;
    },
    merge: function(lo, hi) {
      var hiReport, key, value;
      hiReport = report.create(hi, true);
      for (key in hiReport) {
        value = hiReport[key];
        lo = this.insertKey(lo, key, value);
      }
      return lo;
    },
    toArray: function(value, types) {
      if (!value && !types) {
        return [];
      }
      if (Array.isArray(value)) {
        return value;
      }
      if (value && typeof value === 'object') {
        return Object.keys(value);
      }
      if (!types) {
        return [value];
      }
      types = this.toArray(types);
      if (types.indexOf(typeof value) !== -1) {
        return [value];
      }
      return value;
    }
  };

}).call(this);
