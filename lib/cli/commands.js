// Generated by CoffeeScript 1.12.3

/*
 * Command line interface commands
 */

(function() {
  'use strict';
  var blank, commandList, constraints, dotted, folder, helpers, log, object,
    slice = [].slice;

  blank = {
    '[]': [],
    '{}': {}
  };

  commandList = require('./command_list');

  constraints = require('./constraints');

  dotted = require('../common/dotted');

  helpers = require('./helpers');

  folder = require('../fs/folder');

  log = require('./log');

  object = require('../common/object');

  module.exports = {
    add: function(config, key, value) {
      value = blank[value] || value;
      return object.insertKey(config, key, value);
    },
    addScope: function() {
      var config, params, scope;
      config = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      scope = constraints.oe(params);
      constraints = constraints.render(scope);
      return object.merge(config, constraints);
    },
    config: function() {
      var _, config, configParams, configurer, configurerPath, params, ref;
      _ = arguments[0], configParams = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      ref = helpers.fetchConfigurer(configParams), config = ref[0], configurerPath = ref[1], params = ref[2];
      configurer = require(configurerPath);
      config = configurer.apply(configurer, params);
      log.info('configured', {
        path: configurerPath,
        params: params
      });
      config.moduleTitles = helpers.moduleTitles(config);
      return object.merge(config, {
        cli: {
          config: {
            path: configurerPath,
            params: params
          }
        }
      });
    },
    init: function(config, code, spec, title) {
      code = helpers.stripSlash(code);
      if (!folder.isFolder(code)) {
        return log.error('noCodeFolder', code);
      }
      spec = helpers.stripSlash(spec);
      config = {
        title: title || code,
        code: code,
        spec: spec
      };
      config.moduleTitles = helpers.moduleTitles(config);
      return config;
    },
    remove: function(config, key, value) {
      var node, nodePath, property, ref, xPath;
      if (value != null) {
        node = dotted.parse(config, key);
        if (!Array.isArray(node)) {
          return config;
        }
        property = node.indexOf(value);
        if (property === -1) {
          return config;
        }
        key = key + "." + property;
      }
      ref = dotted.parse(config, key, true, true), node = ref[0], property = ref[1], xPath = ref[2];
      if (!Array.isArray(node)) {
        delete node[property];
        return config;
      }
      node = node.filter(function(e) {
        return e !== node[property];
      });
      nodePath = xPath.join('.');
      config = this.remove(config, nodePath);
      object.insertKey(config, nodePath, node);
      return config;
    },
    removeScope: function() {
      var config, constraint, i, len, params, scope, subject, subjects;
      config = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      scope = constraints.oe(params);
      constraints = constraints.render(scope);
      constraints = object.report(constraints, true);
      for (constraint in constraints) {
        subjects = constraints[constraint];
        subjects = object.toArray(subjects);
        for (i = 0, len = subjects.length; i < len; i++) {
          subject = subjects[i];
          config = this.remove(config, constraint, subject);
        }
      }
      return config;
    },
    usage: function(_, command) {
      command = commandList.aliases[command] || command;
      command = commandList.names.indexOf(command) !== -1 ? command : 'brief';
      return log.error('usage', command, true);
    },
    titles: function(config) {
      if (typeof config.code !== 'string') {
        return log.error('codeFolderUndefined');
      }
      config.moduleTitles = helpers.moduleTitles(config);
      return config;
    }
  };

}).call(this);
